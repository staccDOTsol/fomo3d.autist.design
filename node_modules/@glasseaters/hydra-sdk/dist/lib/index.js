"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FanoutClient = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const systemErrors_1 = require("./systemErrors");
const instructions_1 = require("./generated/instructions");
const types_1 = require("./generated/types");
const accounts_1 = require("./generated/accounts");
__exportStar(require("./generated/types"), exports);
__exportStar(require("./generated/accounts"), exports);
__exportStar(require("./generated/errors"), exports);
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const MPL_TM_BUF = mpl_token_metadata_1.MetadataProgram.PUBKEY.toBuffer();
const MPL_TM_PREFIX = "metadata";
function promiseLog(c) {
    console.info(c);
    return c;
}
class FanoutClient {
    constructor(connection, wallet) {
        this.connection = connection;
        this.wallet = wallet;
    }
    static init(connection, wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            return new FanoutClient(connection, wallet);
        });
    }
    fetch(key, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let a = yield this.connection.getAccountInfo(key);
            return type.fromAccountInfo(a)[0];
        });
    }
    sendInstructions(instructions, signers, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            let tx = new web3_js_1.Transaction();
            tx.feePayer = payer || this.wallet.publicKey;
            tx.add(...instructions);
            tx.recentBlockhash = (yield this.connection.getRecentBlockhash()).blockhash;
            if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {
                yield tx.sign(...signers);
            }
            else {
                tx = yield this.wallet.signTransaction(tx);
            }
            try {
                const sig = yield this.connection.sendRawTransaction(tx.serialize(), {
                    skipPreflight: true,
                });
                return {
                    RpcResponseAndContext: yield this.connection.confirmTransaction(sig, this.connection.commitment),
                    TransactionSignature: sig,
                };
            }
            catch (e) {
                const wrappedE = systemErrors_1.ProgramError.parse(e);
                throw wrappedE == null ? e : wrappedE;
            }
        });
    }
    throwingSend(instructions, signers, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            let res = yield this.sendInstructions(instructions, signers, payer || this.wallet.publicKey);
            if (res.RpcResponseAndContext.value.err != null) {
                console.log(yield this.connection.getConfirmedTransaction(res.TransactionSignature));
                throw new Error(JSON.stringify(res.RpcResponseAndContext.value.err));
            }
            return res;
        });
    }
    static fanoutKey(name, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("fanout-config"), Buffer.from(name)], programId);
        });
    }
    static fanoutForMintKey(fanout, mint, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("fanout-config"), fanout.toBuffer(), mint.toBuffer()], programId);
        });
    }
    static membershipVoucher(fanout, membershipKey, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("fanout-membership"),
                fanout.toBuffer(),
                membershipKey.toBuffer(),
            ], programId);
        });
    }
    static mintMembershipVoucher(fanoutForMintConfig, membershipMint, fanoutMint, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("fanout-membership"),
                fanoutForMintConfig.toBuffer(),
                membershipMint.toBuffer(),
                fanoutMint.toBuffer(),
            ], programId);
        });
    }
    static freezeAuthority(mint, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("freeze-authority"), mint.toBuffer()], programId);
        });
    }
    static nativeAccount(fanoutAccountKey, programId = FanoutClient.ID) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("fanout-native-account"), fanoutAccountKey.toBuffer()], programId);
        });
    }
    initializeFanoutInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const [fanoutConfig, fanoutConfigBumpSeed] = yield FanoutClient.fanoutKey(opts.name);
            const [holdingAccount, holdingAccountBumpSeed] = yield FanoutClient.nativeAccount(fanoutConfig);
            const instructions = [];
            const signers = [];
            let membershipMint = spl_token_1.NATIVE_MINT;
            if (opts.membershipModel == types_1.MembershipModel.Token) {
                if (!opts.mint) {
                    throw new Error("Missing mint account for token based membership model");
                }
                membershipMint = opts.mint;
            }
            instructions.push((0, instructions_1.createProcessInitInstruction)({
                authority: this.wallet.publicKey,
                holdingAccount: holdingAccount,
                fanout: fanoutConfig,
                membershipMint: membershipMint,
            }, {
                args: {
                    bumpSeed: fanoutConfigBumpSeed,
                    nativeAccountBumpSeed: holdingAccountBumpSeed,
                    totalShares: opts.totalShares,
                    name: opts.name,
                },
                model: opts.membershipModel,
            }));
            return {
                output: {
                    fanout: fanoutConfig,
                    nativeAccount: holdingAccount,
                },
                instructions,
                signers,
            };
        });
    }
    initializeFanoutForMintInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const [fanoutMintConfig, fanoutConfigBumpSeed] = yield FanoutClient.fanoutForMintKey(opts.fanout, opts.mint);
            const instructions = [];
            const signers = [];
            let tokenAccountForMint = opts.mintTokenAccount ||
                (yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.mint, opts.fanout, true));
            instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.mint, tokenAccountForMint, opts.fanout, this.wallet.publicKey));
            instructions.push((0, instructions_1.createProcessInitForMintInstruction)({
                authority: this.wallet.publicKey,
                mintHoldingAccount: tokenAccountForMint,
                fanout: opts.fanout,
                mint: opts.mint,
                fanoutForMint: fanoutMintConfig,
            }, {
                bumpSeed: fanoutConfigBumpSeed,
            }));
            return {
                output: {
                    tokenAccount: tokenAccountForMint,
                    fanoutForMint: fanoutMintConfig,
                },
                instructions,
                signers,
            };
        });
    }
    addMemberWalletInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const [membershipAccount, voucherBumpSeed] = yield FanoutClient.membershipVoucher(opts.fanout, opts.membershipKey);
            const instructions = [];
            const signers = [];
            instructions.push((0, instructions_1.createProcessAddMemberWalletInstruction)({
                authority: this.wallet.publicKey,
                fanout: opts.fanout,
                membershipAccount,
                member: opts.membershipKey,
            }, {
                args: {
                    shares: opts.shares,
                },
            }));
            return {
                output: {
                    membershipAccount,
                },
                instructions,
                signers,
            };
        });
    }
    addMemberNftInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const [membershipAccount, _vb] = yield FanoutClient.membershipVoucher(opts.fanout, opts.membershipKey);
            const instructions = [];
            const signers = [];
            const [metadata, _md] = yield web3_js_1.PublicKey.findProgramAddress([Buffer.from(MPL_TM_PREFIX), MPL_TM_BUF, opts.membershipKey.toBuffer()], mpl_token_metadata_1.MetadataProgram.PUBKEY);
            instructions.push((0, instructions_1.createProcessAddMemberNftInstruction)({
                authority: this.wallet.publicKey,
                fanout: opts.fanout,
                membershipAccount,
                mint: opts.membershipKey,
                metadata,
            }, {
                args: {
                    shares: opts.shares,
                },
            }));
            return {
                output: {
                    membershipAccount,
                },
                instructions,
                signers,
            };
        });
    }
    unstakeTokenMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const signers = [];
            let mint = opts.membershipMint;
            if (!mint) {
                let data = yield this.fetch(opts.fanout, accounts_1.Fanout);
                mint = data.membershipMint;
            }
            const [voucher, _vbump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.member);
            const stakeAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, voucher, true);
            const membershipMintTokenAccount = opts.membershipMintTokenAccount ||
                (yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, opts.member));
            instructions.push((0, instructions_1.createProcessUnstakeInstruction)({
                instructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
                fanout: opts.fanout,
                member: opts.member,
                memberStakeAccount: stakeAccount,
                membershipVoucher: voucher,
                membershipMint: mint,
                membershipMintTokenAccount: membershipMintTokenAccount,
            }));
            return {
                output: {
                    membershipVoucher: voucher,
                    membershipMintTokenAccount,
                    stakeAccount,
                },
                instructions,
                signers,
            };
        });
    }
    stakeForTokenMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const signers = [];
            let mint = opts.membershipMint;
            let auth = opts.fanoutAuthority;
            if (!mint || !auth) {
                let data = yield this.fetch(opts.fanout, accounts_1.Fanout);
                mint = data.membershipMint;
                auth = data.authority;
            }
            const [voucher, _vbump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.member);
            const stakeAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, voucher, true);
            const membershipMintTokenAccount = opts.membershipMintTokenAccount ||
                (yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, auth));
            try {
                yield this.connection.getTokenAccountBalance(stakeAccount);
            }
            catch (e) {
                instructions.push(yield spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, stakeAccount, voucher, opts.payer));
            }
            try {
                yield this.connection.getTokenAccountBalance(membershipMintTokenAccount);
            }
            catch (e) {
                throw new Error("Membership mint token account for authority must be initialized");
            }
            instructions.push((0, instructions_1.createProcessSetForTokenMemberStakeInstruction)({
                fanout: opts.fanout,
                authority: auth,
                member: opts.member,
                memberStakeAccount: stakeAccount,
                membershipVoucher: voucher,
                membershipMint: mint,
                membershipMintTokenAccount: membershipMintTokenAccount,
            }, {
                shares: opts.shares,
            }));
            return {
                output: {
                    membershipVoucher: voucher,
                    membershipMintTokenAccount,
                    stakeAccount,
                },
                instructions,
                signers,
            };
        });
    }
    stakeTokenMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const signers = [];
            let mint = opts.membershipMint;
            if (!mint) {
                let data = yield this.fetch(opts.fanout, accounts_1.Fanout);
                mint = data.membershipMint;
            }
            const [voucher, _vbump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.member);
            const stakeAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, voucher, true);
            const membershipMintTokenAccount = opts.membershipMintTokenAccount ||
                (yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, opts.member));
            try {
                yield this.connection.getTokenAccountBalance(stakeAccount);
            }
            catch (e) {
                instructions.push(yield spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, stakeAccount, voucher, opts.payer));
            }
            try {
                yield this.connection.getTokenAccountBalance(membershipMintTokenAccount);
            }
            catch (e) {
                throw new Error("Membership mint token account for member must be initialized");
            }
            instructions.push((0, instructions_1.createProcessSetTokenMemberStakeInstruction)({
                fanout: opts.fanout,
                member: opts.member,
                memberStakeAccount: stakeAccount,
                membershipVoucher: voucher,
                membershipMint: mint,
                membershipMintTokenAccount: membershipMintTokenAccount,
            }, {
                shares: opts.shares,
            }));
            return {
                output: {
                    membershipVoucher: voucher,
                    membershipMintTokenAccount,
                    stakeAccount,
                },
                instructions,
                signers,
            };
        });
    }
    signMetadataInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let authority = opts.authority, holdingAccount = opts.holdingAccount;
            if (!authority || !holdingAccount) {
                const fanoutObj = yield this.fetch(opts.fanout, accounts_1.Fanout);
                authority = fanoutObj.authority;
                holdingAccount = fanoutObj.accountKey;
            }
            const instructions = [];
            const signers = [];
            instructions.push((0, instructions_1.createProcessSignMetadataInstruction)({
                fanout: opts.fanout,
                authority: authority,
                holdingAccount: holdingAccount,
                metadata: opts.metadata,
            }));
            return {
                output: {},
                instructions,
                signers,
            };
        });
    }
    distributeTokenMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const signers = [];
            let fanoutMint = opts.fanoutMint || spl_token_1.NATIVE_MINT;
            let holdingAccount;
            let [fanoutForMint, fanoutForMintBump] = yield FanoutClient.fanoutForMintKey(opts.fanout, fanoutMint);
            let [fanoutForMintMembershipVoucher, fanoutForMintMembershipVoucherBumpSeed,] = yield FanoutClient.mintMembershipVoucher(fanoutForMint, opts.member, fanoutMint);
            let fanoutMintMemberTokenAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.member);
            if (opts.distributeForMint) {
                holdingAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.fanout, true);
                try {
                    yield this.connection.getTokenAccountBalance(fanoutMintMemberTokenAccount);
                }
                catch (e) {
                    instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, fanoutMintMemberTokenAccount, opts.member, opts.payer));
                }
            }
            else {
                const [nativeAccount, _nativeAccountBump] = yield FanoutClient.nativeAccount(opts.fanout);
                holdingAccount = nativeAccount;
            }
            const [membershipVoucher, membershipVoucherBump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.member);
            const stakeAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.membershipMint, membershipVoucher, true);
            const membershipMintTokenAccount = opts.membershipMintTokenAccount ||
                (yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.membershipMint, opts.member));
            try {
                yield this.connection.getTokenAccountBalance(stakeAccount);
            }
            catch (e) {
                instructions.push(yield spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.membershipMint, stakeAccount, membershipVoucher, opts.payer));
            }
            instructions.push((0, instructions_1.createProcessDistributeTokenInstruction)({
                memberStakeAccount: stakeAccount,
                membershipMint: opts.membershipMint,
                fanoutForMint: fanoutForMint,
                fanoutMint: fanoutMint,
                membershipVoucher: membershipVoucher,
                fanoutForMintMembershipVoucher,
                holdingAccount,
                membershipMintTokenAccount: membershipMintTokenAccount,
                fanoutMintMemberTokenAccount,
                payer: opts.payer,
                member: opts.member,
                fanout: opts.fanout,
            }, {
                distributeForMint: opts.distributeForMint,
            }));
            return {
                output: {
                    membershipVoucher,
                    fanoutForMintMembershipVoucher,
                    holdingAccount,
                },
                instructions,
                signers,
            };
        });
    }
    distributeNftMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!opts.membershipKey) {
                throw new Error("Missing membership key");
            }
            const instructions = [];
            const signers = [];
            let fanoutMint = opts.fanoutMint || spl_token_1.NATIVE_MINT;
            let holdingAccount;
            let [fanoutForMint, fanoutForMintBump] = yield FanoutClient.fanoutForMintKey(opts.fanout, fanoutMint);
            let [fanoutForMintMembershipVoucher, fanoutForMintMembershipVoucherBumpSeed,] = yield FanoutClient.mintMembershipVoucher(fanoutForMint, opts.membershipKey, fanoutMint);
            let fanoutMintMemberTokenAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.member);
            if (opts.distributeForMint) {
                holdingAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.fanout, true);
                try {
                    yield this.connection.getTokenAccountBalance(fanoutMintMemberTokenAccount);
                }
                catch (e) {
                    instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, fanoutMintMemberTokenAccount, opts.member, opts.payer));
                }
            }
            else {
                const [nativeAccount, _nativeAccountBump] = yield FanoutClient.nativeAccount(opts.fanout);
                holdingAccount = nativeAccount;
            }
            const membershipKeyTokenAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, opts.membershipKey, opts.member);
            const [membershipVoucher, membershipVoucherBump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.membershipKey);
            instructions.push((0, instructions_1.createProcessDistributeNftInstruction)({
                fanoutForMint: fanoutForMint,
                fanoutMint: fanoutMint,
                membershipKey: opts.membershipKey,
                membershipVoucher: membershipVoucher,
                fanoutForMintMembershipVoucher,
                holdingAccount,
                membershipMintTokenAccount: membershipKeyTokenAccount,
                fanoutMintMemberTokenAccount,
                payer: opts.payer,
                member: opts.member,
                fanout: opts.fanout,
            }, {
                distributeForMint: opts.distributeForMint,
            }));
            return {
                output: {
                    membershipVoucher,
                    fanoutForMintMembershipVoucher,
                    holdingAccount,
                },
                instructions,
                signers,
            };
        });
    }
    distributeWalletMemberInstructions(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = [];
            const signers = [];
            let fanoutMint = opts.fanoutMint || spl_token_1.NATIVE_MINT;
            let holdingAccount;
            let [fanoutForMint, fanoutForMintBump] = yield FanoutClient.fanoutForMintKey(opts.fanout, fanoutMint);
            let [fanoutForMintMembershipVoucher, fanoutForMintMembershipVoucherBumpSeed,] = yield FanoutClient.mintMembershipVoucher(fanoutForMint, opts.member, fanoutMint);
            let fanoutMintMemberTokenAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.member);
            if (opts.distributeForMint) {
                holdingAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, opts.fanout, true);
                try {
                    yield this.connection.getTokenAccountBalance(fanoutMintMemberTokenAccount);
                }
                catch (e) {
                    instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, fanoutMint, fanoutMintMemberTokenAccount, opts.member, opts.payer));
                }
            }
            else {
                const [nativeAccount, _nativeAccountBump] = yield FanoutClient.nativeAccount(opts.fanout);
                holdingAccount = nativeAccount;
            }
            const [membershipVoucher, membershipVoucherBump] = yield FanoutClient.membershipVoucher(opts.fanout, opts.member);
            instructions.push((0, instructions_1.createProcessDistributeWalletInstruction)({
                fanoutForMint: fanoutForMint,
                fanoutMint: fanoutMint,
                membershipVoucher: membershipVoucher,
                fanoutForMintMembershipVoucher,
                holdingAccount,
                fanoutMintMemberTokenAccount,
                payer: opts.payer,
                member: opts.member,
                fanout: opts.fanout,
            }, {
                distributeForMint: opts.distributeForMint,
            }));
            return {
                output: {
                    membershipVoucher,
                    fanoutForMintMembershipVoucher,
                    holdingAccount,
                },
                instructions,
                signers,
            };
        });
    }
    initializeFanout(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.initializeFanoutInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    initializeFanoutForMint(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.initializeFanoutForMintInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    addMemberNft(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.addMemberNftInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    addMemberWallet(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.addMemberWalletInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    stakeTokenMember(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.stakeTokenMemberInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    stakeForTokenMember(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.stakeForTokenMemberInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    signMetadata(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.signMetadataInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    unstakeTokenMember(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let { fanout, member, membershipMint, payer } = opts;
            if (!membershipMint) {
                let data = yield this.fetch(opts.fanout, accounts_1.Fanout);
                membershipMint = data.membershipMint;
            }
            const { instructions: unstake_ix, signers: unstake_signers, output, } = yield this.unstakeTokenMemberInstructions(opts);
            const { instructions: dist_ix, signers: dist_signers } = yield this.distributeTokenMemberInstructions({
                distributeForMint: false,
                fanout,
                member,
                membershipMint,
                payer,
            });
            yield this.throwingSend([...dist_ix, ...unstake_ix], [...unstake_signers, ...dist_signers], this.wallet.publicKey);
            return output;
        });
    }
    distributeNft(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.distributeNftMemberInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    distributeWallet(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.distributeWalletMemberInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
    distributeToken(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers, output } = yield this.distributeTokenMemberInstructions(opts);
            yield this.throwingSend(instructions, signers, this.wallet.publicKey);
            return output;
        });
    }
}
exports.FanoutClient = FanoutClient;
FanoutClient.ID = new web3_js_1.PublicKey("hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg");
//# sourceMappingURL=index.js.map